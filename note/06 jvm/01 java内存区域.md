# `java` 虚拟机内存管理

- 运行时数据区
  - 线程共享区：`java`堆、方法区
  - 线程独占区：`java`虚拟机栈（具体指虚拟机栈中的局部变量表）、本地方法栈、程序计数器
- **方法区**：存储运行时常量池、已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据
- **`java` 堆**：存储对象实例
- **虚拟机栈**：存储方法运行时所需要的数据，成为栈帧
- **本地方法栈**：为 `JVM` 所调用到的Native脚本的方法服务
- **程序计数器**：记录当前线程所执行到的字节码的行号



## 1. 程序计数器

### 1.1 知识点

- 程序计数器是一块较小的内存区域，它可以看作是当前线程所执行的字节码的行号指示器
- 程序计数器处于线程独占区
- 如果线程执行的是`java`方法，这个计数器记录的是**<font color=red>正在执行的虚拟机字节码指令的地址</font>**。
- 如果正在执行的是 `native`方法，这个计数器的值为 `undefined`。
- 此区域是唯一 一个在 `java` 虚拟机规范中没有规定任何 `OutOfMemoryError` 情况的区域

### 1.2 补充

- `java` 中没有 `goto` 关键字，是保留字，`java` 本身不用，也不让开发者使用



## 2. 虚拟机栈

- 虚拟机栈描述的是 `java` 方法执行的动态内存模型

- 栈帧：
  
  - 每个方法执行，都会创建一个栈帧，伴随着方法从创建到执行完成。用于存储局部变量表，操作数栈，动态链接，方法出口等
  
- 局部变量表：
  - 存放编译期可知的各种基本数据类型，引用类型，`returnAddress`类型
  - 局部变量表的内存空间在编译期完成分配，当进入一个方法时，这个方法需要的栈帧分配多少内存是固定的，在方法运行期间是不会改变局部变量表的大小
  
- 大小：

  - 会出现栈内存溢出（`java.lang.StackOverflowError`）
  - `OutOfMemory`

  

## 3. 本地方法栈

- `hotspot`虚拟机是不区分本地方法栈和`java`虚拟机栈的，将这两个区域合二为一了
- 虚拟机栈为虚拟机执行 `java`方法服务
- 本地方法栈为虚拟机执行 `native`方法服务



## 4.堆内存

- 存储对象的实例，存储了几乎所有的对象，除了编译期和运行期优化后的一些对象
- 垃圾收集器管理的主要区域
- 新生代，老年代，Eden空间（为了方便垃圾回收分为多个区域）
- `OutOfMemory`
- 参数，指定堆的大小： **`-Xmx` 和 `-Xms`**



## 5. 方法区

- 存储虚拟机加载的**类信息，常量，静态变量，即时编译器编译后的代码** 等数据
  - 类信息：类的版本、类的字段、类的方法、类的接口
- 方法区 和 永久代
  - 在 `hotspot`虚拟机中使用永久代来实现方法区
  - 在其他虚拟机中，有的都不存在永久代的概念
  - 在虚拟机规范中，方法区与永久代并不等价
- 垃圾回收在方法区的行为
  - 对常量池的回收
  - 对象类型的卸载
- 异常的定义
  - `OutOfMemoryError`



## 6.运行时常量池

- 属于方法区

- 存放编译器生成的各种字面量以及符号引用，这部分内容将在类加载后进入常量池中存放

- 实例：

  ```java
  public class Test {
      public static void main(String[] args) {
          // 局部变量表中存储基础类型的数据和引用类型的引用
          // 引用s1与s2指向常量池中同一个常量，常量池可以看作是一个hashmap，没有指向堆
          String s1 = "abc";
          String s2 = "abc";
          System.out.println(s1 == s2);          // true
          
          String s3 = new String("abc");
          System.out.println(s1 == s3);          // false
        
          System.out.prinln(s1 == s3.intern());  // true
      }
  }
  ```
  
  -  `s1` 和 `s2` 都指向常量池中的同一个常量
  - `s3` 是 `new` 出来的对象，存放在堆中
  - `s3.intern()` 将`s3`对应的堆中的对象数据搬到常量池中 (**运行时产生的常量，运行时常量**)
    - `intern()` 的实现是通过 `native`方法实现的



## 7. 直接内存

- 直接内存不是运行时数据区的一部分，也不是`java`虚拟机规范中定义的一块区域
- `jdk1.4` 添加了`newIO` ，弥补I/O的性能，引入了基于缓冲区的，能够分配对外内存，不受制于`java`虚拟机的制约





https://www.cnblogs.com/adamjwh/p/9683705.html

































