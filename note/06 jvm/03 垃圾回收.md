# 垃圾回收

## 1. 如何判定对象为垃圾对象

### 1.1 引用计数法

- 定义：

  - 在对象中添加一个引用计数器，当有地方引用这个对象的时候，引用计数器的值就+1

- 优点：

  - 实现简单，判定效率高

- 缺点：

  - ```java
    public class Demo {
        private Object reference;
    
        public static void main(String[] args) {
        	Demo demo1 = new Demo();
            Demo demo2 = new Demo();
            // 循环引用
            demo1.reference = demo2;
            demo2.reference = demo1;
            // 断掉原来的引用
            demo1 = null;
            demo2 = null;
    	}
    }
    ```
    
  - 循环引用的对象不会回收



### 1.2 可达性分析

- 思路：
  - 定义一个垃圾回收的根节点`GCRoot`，从根节点出发向下搜索
  - 可以作为`GCRoot`的对象：
    - 虚拟机栈（默认是虚拟机栈中的局部变量表）
    - 方法区的类属所引用的对象
    - 方法区中常量所引用的对象
    - 本地方法栈中引用的对象



**补充：**

1. **打印垃圾回收的日志信息，两个参数：**
   - `-verbose:gc`                   打印简单的信息
   - `-XX:+PrintGCDetails`  打印详细的信息




## 2. 如何回收

### 2.1 回收策略

- 标记-清除算法
- 复制算法
- 标记-整理算法
- 分代收集算法

#### 2.1.1  标记-清除算法 

- 定义：
  - 通过可达性算法，标出不能到达的对象，在之后的垃圾回收中将其清除掉

- 缺点：
  1. 效率问题
  2. 空间问题：标记清除后留下空间碎片过多，不利于大对象的创建

#### 2.1.2 复制算法

- 作用：
  
  - 用来解决标记-清除算法的缺点
- 内存：
  - 堆：
    - 新生代：
      - Eden : 伊甸园
      - Survivor : 存活区
      - Tenured Gen
    - 老年代
  - 方法区

- 定义：

  - `java` 堆分为两部分，将没有被标记的对象复制到另一边，被标记的对象删除掉，避免了出现空间碎片，但是出现了空间浪费，因为只用了一半的堆内存

  - 为了避免浪费，将`java`堆分为三个区域：

    - 最大的区域：Eden区（占`java`堆的80%）
    - 两块Survivor区域（各占`java`堆的10%）

- 步骤：（针对新生代）
  - 创建对象时，直接放到Eden区，一旦Eden快满了，`gc`就出来处理了，它会将存活的对象移到Survivor区（一般认为Eden区对象的存活率为10%不到），然后接着在Eden区存放对象；
  - 一旦Eden又快满了，重复上面的操作，在两个Survivor区执行复制操作；
  - 只浪费10%的内存，这是能接受的，当内存区域不够时，会有解决的方法，内存担保。

#### 2.1.3 标记-整理算法

- 步骤：（针对老年代）
  - 将内存分为两部分，没有明确的划分，左边作为存活的区域，右边作为标记回收的区域；
  - 垃圾回收前，先将整个老年代内存中的所有被标记的对象向右边移动，存活的向左边移动，最后形成左边都是存活的，右边都是被标记回收的；
  - 垃圾回收器直接将右边的内存空间清理掉

#### 2.1.4 分代收集算法

- 定义：
  - 并是新的算法，是将标记-整理算法 和 复制算法进行结合，形成的算法
- 根据内存的分代，选择不同的垃圾回收算法
  - 新生代，或者内存回收率较高的，选择复制算法
  - 老年代，或者内存回收率较低的，选择标记-整理算法

### 2.2 常见的垃圾回收器

- `Serial`
- `Parnew`
- `Cms`
- `G1`

#### 2.2.1 Serial 垃圾收集器

- 出现最早的，历史最悠久的
- 最基本的
- **<font color=red>单线程</font>** 的垃圾收集器
- 客户端常使用



#### 2.2.2 `Parnew` 垃圾收集器

- 在客户端的性能不如 `Serial`垃圾收集器
- **<font color=red>多线程</font>** 的垃圾收集器，缩短垃圾收集器执行时间
- 复制算法（新生代收集器）



#### 2.2.3 `Parallel Scavenge` 垃圾收集器

- 复制算法（新生代收集器）
- **<font color=red>多线程</font>** 的垃圾收集器
- 达到可控制吞吐量
  - 吞吐量：CPU用于

- `-XX:MaxGFPauseMills` 垃圾收集器停顿时间

- `-XX:CGTimeRatio` 吞吐量大小



#### 2.2.4 `G1` 垃圾收集器



## 3. 何时回收